\subsection{Основные классы библиотеки}

\subsubsection{BeaconLocation}

Класс \texttt{BeaconLocation} – центральный класс библиотеки. Предполагается, что пользователь начинает работу с инстанцирования этого класса. Во время создания \texttt{BeaconLocation} создает необходимые объекты \texttt{CoreLocation} (\texttt{CLBeaconRegion}, \texttt{CLLocationManager}), а так же подписывается на обновления данных, получаемых от маячков.

Кроме того, здесь же происходит создание классов \texttt{Processor}, который ответственен за вычисление новых координат пользователя, и \texttt{Floor}, который является хранилищем всех идендификаторов маячков, их координат и очередных показаний.

\subsubsection{Floor}

Класс \texttt{Floor} инкапсулирует маячки, расположенные на этаже. Также пре\-до\-став\-ляет набор методов, с помощью которых пользователь может добавить новые маячки, получить информацию об уже имеющихся и удалить указанные. Предполагается, что задающие их координаты измеряются в метрах, так как обновления значений расстояний до маячков тоже формируются в метрах самой библиотекой \texttt{CoreLocation}.

\subsubsection{Processor}

Класс \texttt{Processor} - ядро библиотеки. По умолчанию он подписывается на события об изменении вычисленных расстояний до маячков, и вычисляет на их основе новое положение пользователя. 
Пользователю предлагаются 3 готовых алгоритма, а также делегат, с помощью которого он может реализовать и использовать собственный метод. Кроме того, есть возможность использовать комбинацию из имеющихся алгоритмов для достижения лучшего результата.

Степень доверия результату каждого из алгоритмов может быть указана в параметрах метода \\
\begin{small}
\texttt{-(void)setAlgorithmsAndTrusts:(NSDictionary<NSNumber*, NSNumber*>*)algorithms}
\end{small}

Переданные в паре с каждым из алгоритмов числа нормируются к единице. Пусть первый алгоритм вычислил положение пользователя как точку с координатами $(1; 1)$. Второй используемый алгоритм - как точку $(5; 5)$. По умолчанию, все алгоритмы эквивалентно важны, и общим результатом будет среднее арифметическое: точка $(3; 3)$. Если второй алгоритм вдвое более важен, чем первый, то результат будет вычислен как $0,66*(5; 5) + 0,33*(1; 1)$, то есть $(3,66; 3,66)$.

\subsubsection{Attractor и Spot}

Для того, чтобы сделать приложение более отзывчивым во время приближения пользователя к некоторому объекту, в библиотеке предусмотрены классы \texttt{Attractor} и \texttt{Spot}. 

\texttt{Spot} - класс, представляющий некоторую <<горячую точку>> в локационном контексте приложения, другими словами, место, в котором мы ожидаем увидеть пользователя чаще, чем в другом (витрина в магазине, экспонат в музее). 

Работа с ними осуществляется через класс \texttt{Attractor}. После того, как точки добавлены, а положение пользователя вычислено, \texttt{Attractor} приближает положение пользователя к ближайшей <<горячей точке>>, основываясь на определенным пользователем коэффициенте (<<сила притяжения>> - \texttt{attractorPo\-wer}). Учтена и <<мертвая зона>>, внутри которой \texttt{Attractor } перестает приближать положение пользователя к указанной отметке.

Все это позволяет создавать более дружественный интерфейс разрабатываемого приложения.