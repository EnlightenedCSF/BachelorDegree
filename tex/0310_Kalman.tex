\subsection{Анализ лиейного фильтра Калмана}

В рамках исследуемой работы возникает небходимость фильтровать некоторые данные. Прежде всего, к ним относятся значения RSSI, получаемые от маячков.

Фильтр Калмана был выбран на основании нескольких положений \cite{eikhoff}:

\begin{enumerate}
    \item
    Фильтр имеет рекуррентную форму, благодаря чему он удобен для программирования. Кроме того, так как новые оценки формируются на основе старых, нет необходимости хранить весь массив наблюдений, что экономит память и время работы.
    \item
    Алгоритм фильтрации одновременно представляет собой непосредственное описание способа реализации фильтра.
    \item    
    Его легко распространить на нестационарные сигналы; это относится и к случаю, когда наблюдения начинаются в произвольный момент времени.
    \item
    Легко распространяется на многомерный случай.
\end{enumerate}

К тому же, скользящее среднее при большем размере окна (обозачим размер за $N$) будет отражать не актуальные данные, а лишь усреднение за последние $N$ измерений. Калман же при большем доверии новому значению больше приближает показание к последнему измеренному, при этом не исключая корректировки выбросов.

Фильтр Калмана использует динамическую модель системы (например, физический закон движения), известные управляющие воздействия и множество последовательных измерений для формирования оптимальной оценки состояния. Алгоритм состоит из двух повторяющихся фаз: \textit{предсказание} и \textit{корректировка}. 

На первом рассчитывается предсказание состояния в следующий момент времени (с учетом неточности их измерения). На втором новая информация с датчика корректирует предсказанное значение (также с учетом неточности и зашумленности этой информации). Важно отметить, что задача фильтрации – получить наиболее близкое значение к реальной величине.

Рассмотрим алгоритм фильтра в общем случае для следующих имеющихся данных: 

\begin{numcases}{}
    x_{k+1} = x_k + u_k + \xi_k \label{new_x}
    \\ 
    z_k = x_k + \eta_k \label{new_z}
\end{numcases}
где $x_k$ – измеряемая величина; \\
$u_k$ – член, отвечающий за контроль системы извне (закон, по которому изменяется величина $x$); \\
$\xi_k$ – ошибка модели, то есть разница между реальным значением и рассчитанным;\\
$\eta_k$ – ошибка, образовавшаяся в результате измерения сенсором;\\
$z_k$ – полученные данные с сенсора;\\
$x_{k+1}$ – новое значение величины на очередном шаге итерации.

Задача состоит в том, что, зная неверные показания сенсора $z_k$, найти хорошее приближение для истинного значения $x_k$. Это хорошее приближение мы будем обозначать как $x_k^{opt}$.

Будем рассуждать по индукции. Представим, что мы уже нашли отфильтрованное значение с сенсора $x_k^{opt}$. Можно предположить, что на шаге $k+1$ система эволюционирует согласно закону \ref{new_x}, и сенсор покажет значение, близкое к $x_k^{opt} + u_k$. С другой стороны, зная соотношение \ref{new_z}, мы будем знать неточное значение сенсора $z_{k+1}$.

Идея Калмана состоит в том, что чтобы получить наилучшее приближение к истинной координате $x_{k+1}$, мы должны выбрать золотую середину между показанием неточного сенсора и $x_k^{opt} + u_k$ — нашим предсказанием того, что мы ожидали от него увидеть. Показанию сенсора мы дадим вес $K$ а на предсказанное значение останется вес $(1-K)$:
\[
    x_{k+1}^{opt} = Kz_{k+1} + (1-K)(x_k^{opt} + u_k)
\]
Коэффициент K называют коэффициентом Калмана.

Согласно выводам самого Калмана, коэффициент имеет свойство стабилизироваться после небольшого числа итераций \cite{kalmanKinect}.

Алгоритм обладает достаточной гибкостью: он позволяет задать априорную информацию о характере системы, связи переменных, и на основании этого строить более точную оценку. Кроме того, даже в случае отсутствия априорной информации фильтр дает отличные результаты \cite{web:habrKalmanTut, web:habrKalmanIntro}.